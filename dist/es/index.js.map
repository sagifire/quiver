{"version":3,"file":"index.js","sources":["../../src/core/HttpException.ts","../../src/core/http.ts","../../src/core/Router.ts","../../src/services/StaticIndex.ts","../../src/core/compose.ts","../../src/route-types/PathRouteType.ts","../../src/route-types/PatternRouteType.ts","../../src/route-types/StaticRouteType.ts"],"sourcesContent":["export class HttpException extends Error {\r\n    constructor(\r\n        public statusCode: number,\r\n        message = 'Http Error',\r\n        public expose = statusCode < 500,\r\n        public headers: Record<string, string> = {}\r\n    ) { \r\n        super(message) \r\n    }\r\n}\r\n","import type { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { HttpException } from './HttpException.js'\r\n\r\nexport type Method =\r\n    | 'GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'\r\n\r\nexport class RequestContext {\r\n\r\n    constructor(\r\n        public req: IncomingMessage,\r\n        public res: ServerResponse,\r\n    ) {}\r\n\r\n    url!: URL; // fill in router\r\n    params: Record<string,string> = Object.create(null)\r\n    locals: Record<string, unknown> = Object.create(null)\r\n\r\n    // Configurable limits\r\n    limits = { \r\n        bodySize: 16 * 1024, \r\n        headerTimeoutMs: 30_000, \r\n        requestTimeoutMs: 60_000 \r\n    }\r\n\r\n    // response API \r\n    status(code: number) { \r\n        this.res.statusCode = code\r\n        return this\r\n    }\r\n\r\n    header(k: string, v: string) { \r\n        this.res.setHeader(k, v)\r\n        return this\r\n    }\r\n\r\n    json(obj: unknown) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n        } \r\n        this.res.end(JSON.stringify(obj))\r\n    }\r\n\r\n    text(s: string) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'text/plain; charset=utf-8')\r\n        }\r\n        this.res.end(s)\r\n    }\r\n\r\n    // Request body with limit and abort-safe\r\n    async bodyRaw(limit = this.limits.bodySize): Promise<Buffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const chunks: Buffer[] = []\r\n            let size = 0, done = false\r\n            const fail = (err: Error) => { \r\n                if (!done) { \r\n                    done = true\r\n                    this.req.destroy()\r\n                    reject(err)\r\n                }\r\n            }\r\n            const ok = () => {\r\n                if (!done) {\r\n                    done = true\r\n                    resolve(Buffer.concat(chunks))\r\n                }\r\n            }\r\n\r\n            this.req.once('error', fail)\r\n            this.req.once('aborted', () => fail(new HttpException(499, 'Client Closed Request', true)))\r\n            this.req.on('data', (c: Buffer) => {\r\n                size += c.length\r\n                if (size > limit) return fail(new HttpException(413, 'Content Too Large', true))\r\n                chunks.push(c)\r\n            })\r\n            this.req.once('end', ok)\r\n        })\r\n    }\r\n\r\n    async bodyJson<T = unknown>(limit?: number): Promise<T> {\r\n        const raw = await this.bodyRaw(limit);\r\n        try { \r\n            return JSON.parse(raw.toString('utf8')) as T\r\n        }\r\n        catch { \r\n            throw new HttpException(400, 'Invalid JSON', true)\r\n        }\r\n    }\r\n}\r\n\r\nexport type Handler<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport type Pipe<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport type RouteTypeName = string\r\n\r\nexport interface RouteRuleBase<Ctx extends RequestContext = RequestContext> {\r\n    type: RouteTypeName\r\n    handler: Handler<Ctx>\r\n    pipes?: readonly Pipe<Ctx>[]\r\n}\r\n\r\nexport interface IRouteType<\r\n    Ctx extends RequestContext = RequestContext,\r\n    TRule extends RouteRuleBase<Ctx> = RouteRuleBase<Ctx>\r\n> {\r\n    readonly typeName: RouteTypeName\r\n    addRule(rule: TRule): void\r\n    match(ctx: Ctx): ((ctx: Ctx) => void | Promise<void>) | null\r\n}","import { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { RequestContext, Pipe, IRouteType, RouteRuleBase, RouteTypeName } from './http.js'\r\n\r\nexport type RuleRegistry<Ctx extends RequestContext> = Record<RouteTypeName, RouteRuleBase<Ctx>>\r\n\r\nexport type RuleOfType<T, Ctx extends RequestContext> = T extends IRouteType<Ctx, infer R> ? R : never\r\n\r\nexport type TypeRegistry<Ctx extends RequestContext> = Record<RouteTypeName, IRouteType<Ctx>>\r\n\r\nexport type TypeNameOfRuleType<T> = T extends { typeName: infer R } ? R : never\r\nexport type TypeNameOfRule<T> = T extends { type: infer R } ? R : never\r\n\r\nexport type DiscriminatedRuleUnion<RuleRegistry extends Record<RouteTypeName, any>> =\r\n    keyof RuleRegistry extends never\r\n        ? never\r\n        : RuleRegistry[keyof RuleRegistry]\r\n\r\nexport type CtxFactory<Ctx extends RequestContext> =\r\n    | { class: new (req: IncomingMessage, res: ServerResponse) => Ctx, factory?: never }\r\n    | { factory: (req: IncomingMessage, res: ServerResponse) => Ctx, class?: never }\r\n    | undefined        \r\n\r\nexport class Router<\r\n    Ctx extends RequestContext = RequestContext,\r\n    RReg extends RuleRegistry<Ctx> = {}\r\n> {\r\n    private reg: TypeRegistry<Ctx>\r\n    private order: string[] = []\r\n    private ctxFactory?: CtxFactory<Ctx>\r\n    private globalPipes: Array<Pipe<Ctx>> = []\r\n\r\n    constructor(opts?: { context?: CtxFactory<Ctx> }) {\r\n        this.reg = {} as TypeRegistry<Ctx>\r\n        this.ctxFactory = opts?.context\r\n    }\r\n\r\n    useType<T extends IRouteType<Ctx, RouteRuleBase<Ctx>>>(\r\n        type: T\r\n    ): Router<Ctx, RReg & { [K in TypeNameOfRuleType<T>]: RuleOfType<T, Ctx> }> {\r\n        ;(this.reg as any)[type.typeName] = type\r\n        this.order.push(type.typeName)\r\n        return this as unknown as Router<Ctx, RReg & { [K in TypeNameOfRuleType<T>]: RuleOfType<T, Ctx>}>\r\n    }\r\n\r\n    useGlobalPipes(...pipes: Pipe<Ctx>[]) {\r\n        this.globalPipes.push(...pipes)\r\n        return this\r\n    }\r\n\r\n    addRule(rule: DiscriminatedRuleUnion<RReg>) {\r\n        const typeName = (rule as any).type as keyof RReg\r\n        const rt = (this.reg as any)[typeName] as IRouteType<Ctx, RouteRuleBase<Ctx>> | undefined\r\n        if (!rt) {\r\n            throw new Error(`Route type \"${String(typeName)}\" is not registered`)\r\n        }\r\n        const { type: _omit, ...pureRule } = rule as any\r\n        rt.addRule(pureRule)\r\n        return this\r\n    }\r\n\r\n    addRules(rules: Array<DiscriminatedRuleUnion<RReg>>) {\r\n        for (const r of rules) {\r\n            this.addRule(r)\r\n        }\r\n        return this\r\n    }\r\n\r\n    private makeCtx(req: IncomingMessage, res: ServerResponse): Ctx {\r\n        if (this.ctxFactory?.factory) {\r\n            return this.ctxFactory.factory(req, res)\r\n        }\r\n        if (this.ctxFactory?.class) {\r\n            return new this.ctxFactory.class(req, res)\r\n        }\r\n        return new RequestContext(req, res) as Ctx\r\n    }\r\n\r\n    async handler(req: IncomingMessage, res: ServerResponse) {\r\n        const ctx = this.makeCtx(req, res)\r\n        const base = 'http://' + (req.headers.host || 'localhost')\r\n        ctx.url = new URL(req.url || '/', base)\r\n\r\n        try {\r\n            for (const globalPipe of this.globalPipes) {\r\n                await globalPipe(ctx)\r\n            }\r\n\r\n            for (const name of this.order) {\r\n                const routeType = (this.reg as any)[name] as IRouteType<Ctx, any>\r\n                const exec = routeType.match(ctx)\r\n                if (exec) {\r\n                    return await exec(ctx)\r\n                }\r\n            }\r\n\r\n            res.statusCode = 404\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: 'Not Found' }))\r\n        } catch (e: any) {\r\n            const code = e?.statusCode ?? 500\r\n            res.statusCode = code\r\n            if (e?.headers) {\r\n                for (const [k, v] of Object.entries(e.headers)) {\r\n                    res.setHeader(k, String(v))\r\n                }\r\n            }\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: e?.expose ? e.message : 'Internal Server Error' }))\r\n        }\r\n    }\r\n}","// static-index.ts\r\nimport { promises as fsp, Dirent, Stats } from 'node:fs'\r\nimport path from 'node:path'\r\n\r\nexport interface StaticIndexOptions {\r\n    rootDir: string\r\n    urlBase: string\r\n    indexFiles?: string[]\r\n    scanIntervalMs?: number\r\n    followSymlinks?: boolean\r\n    maxFiles?: number\r\n    maxDepth?: number\r\n    allowWellKnown?: boolean\r\n    logger?: {\r\n        warn: (...params:any[]) => void\r\n        debug: (...params:any[]) => void\r\n    }\r\n}\r\n\r\nexport class StaticIndex {\r\n    private map = new Map<string,string>() // \"/static/a/b.js\" => \"/abs/a/b.js\"\r\n    private root!: string\r\n    private base!: string\r\n    private timer?: NodeJS.Timeout\r\n    private indexFiles:  Set<string>\r\n\r\n    constructor(private opts: StaticIndexOptions) {\r\n        this.root = path.resolve(opts.rootDir)\r\n        // preserve root \"/\" as a distinct base; otherwise trim trailing slash\r\n        this.base = opts.urlBase === '/' ? '/' : (opts.urlBase.endsWith('/') ? opts.urlBase.slice(0, -1) : opts.urlBase)\r\n        this.indexFiles = new Set<string>(opts.indexFiles ? opts.indexFiles : ['index.html', 'index.htm'])\r\n    }\r\n\r\n    async start(): Promise<void> {\r\n        await this.rebuild().catch(()=>{})\r\n        if (this.opts.scanIntervalMs) {\r\n            this.timer = setInterval(() => this.rebuild().catch(()=>{}), this.opts.scanIntervalMs)\r\n            this.timer.unref?.()\r\n        }\r\n    }\r\n\r\n    stop() { \r\n        if (this.timer) clearInterval(this.timer)\r\n    }\r\n\r\n    // O(#files). Для великих дерев — інкрементал або шардінг по підкаталогах\r\n    private async rebuild() {\r\n        const next = new Map<string, string>()\r\n        const visitedDirs = new Set<string>()\r\n\r\n        // 1) Real root\r\n        const rootReal = await fsp.realpath(this.root).catch(() => this.root)\r\n\r\n        const inRoot = (p: string) =>\r\n            p === rootReal || p.startsWith(rootReal + path.sep)\r\n\r\n        // basePrefix used to avoid double slashes when base === '/'\r\n        const basePrefix = this.base === '/' ? '' : this.base\r\n\r\n        const walk = async (dirAbs: string, rel: string, depth = 0) => {\r\n            // (optional) depth limit\r\n            if (this.opts.maxDepth && depth > this.opts.maxDepth) {\r\n                return\r\n            }\r\n\r\n            let entries: Dirent[]\r\n            try {\r\n                entries = await fsp.readdir(dirAbs, { withFileTypes: true })\r\n            } catch (err) {\r\n                this.opts.logger?.warn?.(`readdir failed: ${dirAbs}`, err)\r\n                return\r\n            }\r\n\r\n            // loop protection \r\n            let dirReal = await fsp.realpath(dirAbs).catch(() => dirAbs)\r\n            if (!inRoot(dirReal)) return; // don't index files without root\r\n            if (visitedDirs.has(dirReal)) {\r\n                return\r\n            }\r\n            visitedDirs.add(dirReal)\r\n\r\n            for (const e of entries) {\r\n                const name = e.name\r\n                if (name.startsWith('.')) {\r\n                    if (!(this.opts.allowWellKnown && name === '.well-known')) {\r\n                        continue\r\n                    }\r\n                }\r\n\r\n                const childAbs = path.join(dirAbs, name)\r\n                const childRel = rel ? rel + '/' + name : name\r\n\r\n                let lst: Stats\r\n                try {\r\n                    lst = await fsp.lstat(childAbs) // without transition\r\n                } catch (error) {\r\n                    this.opts.logger?.debug?.(`lstat failed: ${childAbs}`, error)\r\n                    continue\r\n                }\r\n\r\n                // Symlink\r\n                if (lst.isSymbolicLink()) {\r\n                    if (!this.opts.followSymlinks) continue\r\n                    let targetReal: string\r\n                    try {\r\n                        targetReal = await fsp.realpath(childAbs)\r\n                    } catch (error) {\r\n                        this.opts.logger?.debug?.(`realpath failed: ${childAbs}`, error)\r\n                        continue;\r\n                    }\r\n                    if (!inRoot(targetReal)) {\r\n                        continue\r\n                    }\r\n\r\n                    // Classifying the target\r\n                    let st: Stats\r\n                    try {\r\n                        st = await fsp.stat(childAbs)\r\n                    } catch (error) {\r\n                        this.opts.logger?.debug?.(`stat failed: ${childAbs}`, error)\r\n                        continue\r\n                    }\r\n                    if (st.isDirectory()) {\r\n                        await walk(childAbs, childRel, depth + 1)\r\n                    } else if (st.isFile()) {\r\n                        const urlPath = `${basePrefix}/${childRel.split(path.sep).join('/')}`\r\n                        next.set(urlPath, childAbs); // save the path via link — ok\r\n                    }\r\n                    continue\r\n                }\r\n\r\n                // Normal files/directories\r\n                if (lst.isDirectory()) {\r\n                    await walk(childAbs, childRel, depth + 1)\r\n                } else if (lst.isFile()) {\r\n                    const urlPath = `${basePrefix}/${childRel.split(path.sep).join('/')}`\r\n                    next.set(urlPath, childAbs)\r\n                }\r\n\r\n                // add index files\r\n                for (const indexFile of this.indexFiles) {\r\n                    const indexFileFullUrl = basePrefix + rel + '/' + indexFile\r\n                    if (next.has(indexFileFullUrl)) {\r\n                        next.set(basePrefix + rel, dirAbs)\r\n                        break\r\n                    }\r\n                }\r\n                // other types — ignore\r\n            }\r\n        };\r\n\r\n        await walk(this.root, '')\r\n\r\n        // (optional) quantity limit\r\n        if (this.opts.maxFiles && next.size > this.opts.maxFiles) {\r\n            this.opts.logger?.warn?.(`file index truncated: ${next.size} > ${this.opts.maxFiles}`)\r\n        }\r\n\r\n        this.map = next // atomic replacement\r\n    }\r\n\r\n    lookup(urlPath: string): string | undefined {\r\n        return this.map.get(urlPath)\r\n    }\r\n\r\n    resolveUrl(url: URL): string | undefined {\r\n        const pathname = url.pathname\r\n\r\n        // Reject any path that contains \"..\" segments to avoid traversal even if normalized\r\n        // also reject empty or non-absolute paths\r\n        if (!pathname || !pathname.startsWith('/')) {\r\n            return undefined\r\n        }\r\n        if (pathname.split('/').includes('..')) {\r\n            return undefined\r\n        }\r\n\r\n        // check base match: if base is '/', allow any absolute path starting with '/'\r\n        if (this.base === '/') {\r\n            // pathname already starts with '/'\r\n        } else {\r\n            if (!(pathname === this.base || pathname.startsWith(this.base + '/'))) {\r\n                return undefined\r\n            }\r\n        }\r\n\r\n        const abs = this.lookup(pathname)\r\n        // додатковий рантайм-захист від traversal (хоч ми індексуємо, все одно перевіримо):\r\n        if (abs && abs.startsWith(this.root)) {\r\n            return abs\r\n        }\r\n        return undefined\r\n    }\r\n}\r\n","import { RequestContext, Handler, Pipe } from './http.js'\r\n\r\nexport function compose<Ctx extends RequestContext>(\r\n    pipes: readonly Pipe<Ctx>[]|undefined,\r\n    handler: Handler<Ctx>\r\n): Handler<Ctx> {\r\n    if (!pipes || pipes.length === 0) {\r\n        return handler\r\n    }\r\n    return async (ctx: Ctx) => {\r\n        for (const pipe of pipes) {\r\n            await pipe(ctx)\r\n        }\r\n        return handler(ctx)\r\n    }\r\n}\r\n","import { IRouteType, RouteRuleBase, RequestContext, Handler } from '../core/http.js'\r\nimport { HttpException } from '../core/HttpException.js'\r\nimport { compose } from '../core/compose.js'\r\n\r\nexport interface PathRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx>\r\n{\r\n    type: 'PATH'\r\n    path: string\r\n    methods?: ('GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS')[]\r\n}\r\n\r\nfunction normalizePath(p: string) {\r\n    if (!p || p === '/') {\r\n        return '/'\r\n    }\r\n    return p.endsWith('/') ? p.slice(0, -1) : p\r\n}\r\n\r\nconst METHOD_ORDER: ReadonlyArray<string> = ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']\r\n\r\nexport class PathRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, PathRule<Ctx>>\r\n{\r\n    readonly typeName = 'PATH'\r\n\r\n    // Бінарний пошук по \"METHOD␠PATH\"\r\n    private keys: string[] = []\r\n    private execs: Handler<Ctx>[] = []\r\n\r\n    // Для 405: індекс шлях → множина дозволених методів\r\n    private pathMethods = new Map<string, Set<string>>()\r\n\r\n    addRule(rule: PathRule<Ctx>) {\r\n        const path = normalizePath(rule.path)\r\n        const methods = (rule.methods?.length ? rule.methods : ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'])\r\n            .map(m => m.toUpperCase())\r\n\r\n        const exe = compose(rule.pipes, rule.handler)\r\n\r\n        for (const m of methods) {\r\n            const key = `${m} ${path}`\r\n            const i = this.lowerBound(this.keys, key)\r\n            this.keys.splice(i, 0, key)\r\n            this.execs.splice(i, 0, exe)\r\n        }\r\n\r\n        let set = this.pathMethods.get(path)\r\n        if (!set) {\r\n            set = new Set<string>()\r\n            this.pathMethods.set(path, set)\r\n        }\r\n        for (const m of methods) {\r\n            set.add(m)\r\n        }\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx>|null {\r\n        const method = (ctx.req.method || 'GET').toUpperCase()\r\n        const path = normalizePath(ctx.url.pathname)\r\n        const key = `${method} ${path}`\r\n\r\n        // 1) Точний збіг: METHOD + PATH\r\n        let i = this.lowerBound(this.keys, key)\r\n        if (i < this.keys.length && this.keys[i] === key) {\r\n            return this.execs[i]!\r\n        }\r\n\r\n        // 2) HEAD → fallback на GET, якщо HEAD не знайдено, але GET існує\r\n        if (method === 'HEAD') {\r\n            const getKey = `GET ${path}`\r\n            i = this.lowerBound(this.keys, getKey)\r\n            if (i < this.keys.length && this.keys[i] === getKey) {\r\n                const getHandler = this.execs[i]!;\r\n                return async (ctx: Ctx) => {\r\n                    // Зберігаємо оригінальний res.end\r\n                    const originalResEnd = ctx.res.end;\r\n                    // Тимчасово перевизначаємо res.end, щоб придушити тіло для HEAD запитів\r\n                    ctx.res.end = (chunk?: any) => {\r\n                        // Нічого не робимо з chunk, просто повертаємо res\r\n                        return ctx.res;\r\n                    };\r\n\r\n                    await getHandler(ctx); // Виконуємо GET обробник для побічних ефектів (наприклад, встановлення заголовків)\r\n\r\n                    // Відновлюємо оригінальний res.end\r\n                    ctx.res.end = originalResEnd;\r\n\r\n                    // Явно встановлюємо статус та завершуємо відповідь для HEAD\r\n                    // Зберігаємо статус, якщо він був встановлений обробником, інакше 200\r\n                    ctx.res.statusCode = ctx.res.statusCode === 200 ? 200 : ctx.res.statusCode;\r\n                    ctx.res.end(); // Відправляємо порожнє тіло\r\n                };\r\n            }\r\n        }\r\n\r\n        // 3) Розрізнення 404 vs 405\r\n        const allowed = this.pathMethods.get(path)\r\n        if (allowed && allowed.size > 0) {\r\n            // RFC: якщо GET дозволено, HEAD теж вважається дозволеним → додамо у Allow\r\n            const allowList = new Set<string>(allowed)\r\n            if (allowed.has('GET')) {\r\n                allowList.add('HEAD')\r\n            }\r\n            const ordered = METHOD_ORDER.filter(m => allowList.has(m))\r\n            const allowHeader = ordered.length ? ordered.join(', ') : Array.from(allowList).join(', ')\r\n            return () => {\r\n                throw new HttpException(405, 'Method Not Allowed', true, { 'Allow': allowHeader })\r\n            }\r\n        }\r\n\r\n        // Інакше — шляху немає зовсім → 404 (Router відпрацює свій notFound)\r\n        return null\r\n    }\r\n\r\n    private lowerBound(arr: string[], key: string): number {\r\n        let l = 0\r\n        let r = arr.length\r\n        while (l < r) {\r\n            const mid = (l + r >>> 1)\r\n            if (arr[mid]! < key) {\r\n                l = mid + 1\r\n            } else {\r\n                r = mid\r\n            }\r\n        }\r\n        return l\r\n    }\r\n}\r\n","// PatternRouteType.ts\r\nimport { IRouteType, Handler, RequestContext, RouteRuleBase, Pipe, Method } from '../core/http.js'\r\nimport { compose } from '../core/compose.js'\r\n\r\nexport interface PatternRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx>\r\n{\r\n    type: 'PATTERN'\r\n    pattern: string\r\n    methods?: Method[]\r\n    constraints?: Record<string, 'int'|'uuid'|'hex'|'alpha'|RegExp|((v: string) => boolean)>\r\n}\r\n\r\n/* ---------------- internals ---------------- */\r\n\r\ntype Validator = (v: string) => boolean\r\n\r\nconst BuiltinValidators: Record<string, Validator> = {\r\n    int:   v => /^-?\\d+$/.test(v),\r\n    uuid:  v => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v),\r\n    hex:   v => /^[0-9a-f]+$/i.test(v),\r\n    alpha: v => /^[A-Za-z]+$/.test(v),\r\n}\r\n\r\nfunction toValidator(\r\n    spec: 'int'|'uuid'|'hex'|'alpha'|RegExp|((v: string) => boolean)|undefined\r\n): Validator|undefined {\r\n    if (!spec) {\r\n        return undefined\r\n    }\r\n    if (typeof spec === 'function') {\r\n        return spec\r\n    }\r\n    if (spec instanceof RegExp) {\r\n        const r = spec\r\n        return v => r.test(v)\r\n    }\r\n    return BuiltinValidators[spec]\r\n}\r\n\r\ntype Token =\r\n    | { t: 'static', val: string }\r\n    | { t: 'param', name: string, validate?: Validator }\r\n    | { t: 'wildcard', name: string } // останній сегмент\r\n\r\nfunction normalizePath(p: string) {\r\n    if (!p || p === '/') {\r\n        return '/'\r\n    }\r\n    return p.endsWith('/') ? p.slice(0, -1) : p\r\n}\r\n\r\nfunction decodeSafe(s: string): string|null {\r\n    try {\r\n        return decodeURIComponent(s)\r\n    } catch {\r\n        return null\r\n    }\r\n}\r\n\r\nfunction parsePattern(pattern: string, constraints?: PatternRule['constraints']): Token[] {\r\n    const clean = normalizePath(pattern)\r\n    if (clean === '/') {\r\n        return []\r\n    }\r\n    const parts = clean.slice(1).split('/')\r\n\r\n    const tokens: Token[] = []\r\n    for (let i = 0; i < parts.length; i++) {\r\n        const seg = parts[i]!\r\n        if (seg.startsWith(':')) {\r\n            const m = /^:([A-Za-z_][A-Za-z0-9_]*)(?:\\((.+)\\))?$/.exec(seg)\r\n            if (!m) {\r\n                throw new Error(`Invalid param segment: ${seg}`)\r\n            }\r\n            const name = m[1]\r\n            if (!name) {\r\n                throw new Error(`Invalid param name in segment: ${seg}`)\r\n            }\r\n            let validate: Validator|undefined\r\n            if (m[2]) {\r\n                validate = toValidator(new RegExp(`^(?:${m[2]})$`))\r\n            } else if (constraints && constraints[name]) {\r\n                validate = toValidator(constraints[name])\r\n            }\r\n            tokens.push({ t: 'param', name, validate })\r\n            continue\r\n        }\r\n        if (seg === '*' || seg.startsWith('*')) {\r\n            const name = seg === '*' ? 'wild' : seg.slice(1)\r\n            if (i !== parts.length - 1) {\r\n                throw new Error('Wildcard must be the last segment')\r\n            }\r\n            tokens.push({ t: 'wildcard', name })\r\n            continue\r\n        }\r\n        tokens.push({ t: 'static', val: seg })\r\n    }\r\n    return tokens\r\n}\r\n\r\ntype Exec<Ctx extends RequestContext> = Handler<Ctx>\r\n\r\nclass Node<Ctx extends RequestContext> {\r\n    sChildren: Map<string, Node<Ctx>>|null = null\r\n    pChild: { name: string, validate?: Validator, node: Node<Ctx> }|null = null\r\n    wChild: { name: string, node: Node<Ctx> }|null = null\r\n    handlers: Map<Method, Exec<Ctx>>|null = null\r\n\r\n    getOrAddStatic(seg: string) {\r\n        if (!this.sChildren) {\r\n            this.sChildren = new Map()\r\n        }\r\n        let n = this.sChildren.get(seg)\r\n        if (!n) {\r\n            n = new Node<Ctx>()\r\n            this.sChildren.set(seg, n)\r\n        }\r\n        return n\r\n    }\r\n\r\n    setParam(name: string, validate?: Validator) {\r\n        // Обмеження на додавання param після wildcard видалено, оскільки пріоритет визначається під час матчингу.\r\n        if (!this.pChild) {\r\n            this.pChild = { name, validate, node: new Node<Ctx>() }\r\n        }\r\n        return this.pChild.node\r\n    }\r\n\r\n    setWildcard(name: string) {\r\n        if (!this.wChild) {\r\n            this.wChild = { name, node: new Node<Ctx>() }\r\n        }\r\n        return this.wChild.node\r\n    }\r\n\r\n    setHandler(methods: Method[], exec: Exec<Ctx>) {\r\n        if (!this.handlers) {\r\n            this.handlers = new Map()\r\n        }\r\n        for (const m of methods) {\r\n            if (this.handlers.has(m)) {\r\n                throw new Error(`Duplicate handler for method ${m}`)\r\n            }\r\n            this.handlers.set(m, exec)\r\n        }\r\n    }\r\n\r\n    getHandler(method: Method): Exec<Ctx>|null {\r\n        if (!this.handlers) {\r\n            return null\r\n        }\r\n        const h = this.handlers.get(method) || (method === 'HEAD' ? this.handlers.get('GET') : undefined)\r\n        return h ?? null\r\n    }\r\n}\r\n\r\n/* ---------------- exported route type ---------------- */\r\n\r\nexport class PatternRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, PatternRule<Ctx>>\r\n{\r\n    readonly typeName = 'PATTERN'\r\n    private root = new Node<Ctx>()\r\n\r\n    addRule(rule: PatternRule<Ctx>) {\r\n        const methods: Method[] = rule.methods?.length\r\n            ? rule.methods\r\n            : ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']\r\n\r\n        const tokens = parsePattern(rule.pattern, rule.constraints)\r\n        const exec = compose(rule.pipes as readonly Pipe<Ctx>[]|undefined, rule.handler as Handler<Ctx>)\r\n\r\n        let node = this.root\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const t = tokens[i]!\r\n            if (t.t === 'static') {\r\n                node = node.getOrAddStatic(t.val)\r\n            } else if (t.t === 'param') {\r\n                node = node.setParam(t.name, t.validate)\r\n            } else {\r\n                node = node.setWildcard(t.name)\r\n                if (i !== tokens.length - 1) {\r\n                    throw new Error('Wildcard must be the last segment')\r\n                }\r\n            }\r\n        }\r\n        node.setHandler(methods, exec)\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx>|null {\r\n        const pathname = normalizePath(ctx.url.pathname)\r\n        const method = (ctx.req.method as Method) || 'GET'\r\n\r\n        if (pathname === '/') {\r\n            // Спочатку перевіряємо статичний обробник для кореневого шляху\r\n            let h = this.root.getHandler(method)\r\n            if (h) {\r\n                return h\r\n            }\r\n            // Якщо статичного обробника немає, перевіряємо wildcard для кореневого шляху (наприклад, /*path)\r\n            if (this.root.wChild) {\r\n                h = this.root.wChild.node.getHandler(method)\r\n                if (h) {\r\n                    // Для кореневого шляху параметр wildcard має бути порожнім рядком\r\n                    return (c: Ctx) => {\r\n                        (c as any).params = { [this.root.wChild!.name]: '' }\r\n                        return h!(c)\r\n                    }\r\n                }\r\n            }\r\n            return null\r\n        }\r\n\r\n        const parts = pathname.slice(1).split('/')\r\n\r\n        let params: Record<string, string>|null = null\r\n\r\n        const go = (node: Node<Ctx>, idx: number): Exec<Ctx>|null => {\r\n            if (idx === parts.length) {\r\n                return node.getHandler(method)\r\n            }\r\n\r\n            const segRaw = parts[idx]\r\n            if (segRaw === undefined) {\r\n                return null\r\n            }\r\n\r\n            const segDec = decodeSafe(segRaw)\r\n            if (segDec === null) {\r\n                return null\r\n            }\r\n\r\n            if (node.sChildren) {\r\n                const next = node.sChildren.get(segDec)\r\n                if (next) {\r\n                    const h = go(next, idx + 1)\r\n                    if (h) {\r\n                        return h\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (node.pChild) {\r\n                const { name, validate, node: pnode } = node.pChild\r\n                if (!validate || validate(segDec)) {\r\n                    if (!params) {\r\n                        params = Object.create(null)\r\n                    }\r\n                    params![name] = segDec\r\n                    const h = go(pnode, idx + 1)\r\n                    if (h) {\r\n                        return h\r\n                    }\r\n                    delete params![name]\r\n                }\r\n            }\r\n\r\n            if (node.wChild) {\r\n                let acc = ''\r\n                for (let i = idx; i < parts.length; i++) {\r\n                    const d = decodeSafe(parts[i]!)\r\n                    if (d === null) {\r\n                        return null\r\n                    }\r\n                    acc += (i === idx ? '' : '/') + d\r\n                }\r\n                if (!params) {\r\n                    params = Object.create(null)\r\n                }\r\n                params![node.wChild.name] = acc\r\n                const h = node.wChild.node.getHandler(method)\r\n                if (h) {\r\n                    return h\r\n                }\r\n                delete params![node.wChild.name]\r\n            }\r\n\r\n            return null\r\n        }\r\n\r\n        const found = go(this.root, 0)\r\n        if (!found) {\r\n            return null\r\n        }\r\n\r\n        return (c: Ctx) => {\r\n            if (params) {\r\n                ;(c as any).params = params\r\n            }\r\n            return found(c)\r\n        }\r\n    }\r\n}\r\n","import { createReadStream, promises as fsp, Stats } from 'node:fs'\r\nimport { extname } from 'node:path'\r\n\r\nimport { RequestContext, IRouteType, RouteRuleBase, Handler } from '../core/http.js'\r\nimport { StaticIndex } from '../services/StaticIndex.js'\r\n\r\nexport type ContentTypeMap = Record<string, string>\r\n\r\ntype Encoding = 'br' | 'gzip'\r\n\r\nexport interface PrecompressedOptions {\r\n    enabled?: boolean\r\n    prefer?: Encoding[]\r\n    useSiblingFiles?: boolean\r\n    resolver?: (abs: string, acceptEncodingHeader: string|undefined) =>\r\n        Promise<{ path: string, encoding: Encoding }|null>\r\n    allowRangesForCompressed?: boolean\r\n    alwaysSetVary?: boolean\r\n}\r\n\r\ntype NormalizedPrecompressed = {\r\n    enabled: boolean\r\n    prefer: Encoding[]\r\n    useSiblingFiles: boolean\r\n    resolver?: (abs: string, acceptEncodingHeader: string|undefined) =>\r\n        Promise<{ path: string, encoding: Encoding }|null>\r\n    allowRangesForCompressed: boolean\r\n    alwaysSetVary: boolean\r\n}\r\n\r\nexport interface StaticRouteOptions {\r\n    index: StaticIndex\r\n\r\n    resolveContentType?: (\r\n        ext: string,\r\n        absPath: string,\r\n        stats: Stats,\r\n        ctx: RequestContext\r\n    ) => string | undefined\r\n\r\n    contentTypes?: ContentTypeMap\r\n    defaultContentType?: string\r\n    defaultTextCharset?: string | false\r\n    precompressed?: PrecompressedOptions\r\n}\r\n\r\nconst BASE_CT: ContentTypeMap = {\r\n    '.html':'text/html; charset=utf-8', '.json':'application/json; charset=utf-8', '.txt':'text/plain; charset=utf-8',\r\n    '.js':'application/javascript; charset=utf-8', '.css':'text/css; charset=utf-8',\r\n    '.png':'image/png', '.jpg':'image/jpeg', '.jpeg':'image/jpeg', '.webp':'image/webp', '.gif':'image/gif', '.svg':'image/svg+xml',\r\n    '.mp4':'video/mp4', '.webm':'video/webm', '.mp3':'audio/mpeg', '.wav':'audio/wav',\r\n}\r\n\r\nfunction normalizeCTMap(src?: ContentTypeMap): ContentTypeMap {\r\n    if (!src) {\r\n        return {}\r\n    }\r\n    const out: ContentTypeMap = {}\r\n    for (const [k, v] of Object.entries(src)) {\r\n        const key = k.startsWith('.') ? k.toLowerCase() : ('.' + k.toLowerCase())\r\n        out[key] = v\r\n    }\r\n    return out\r\n}\r\n\r\nfunction maybeAppendCharset(mime: string, charset: string | false | undefined): string {\r\n    if (!charset) {\r\n        return mime\r\n    }\r\n    if ((/^text\\//.test(mime) || /^application\\/json\\b/.test(mime)) && !/;\\s*charset=/i.test(mime)) {\r\n        return `${mime}; charset=${charset}`\r\n    }\r\n    return mime\r\n}\r\n\r\nfunction parseAcceptEncoding(h: string|undefined) {\r\n    const out = new Map<string, number>()\r\n    if (!h) {\r\n        return out\r\n    }\r\n    const parts = h.split(',')\r\n    for (const raw of parts) {\r\n        const piece = raw.trim()\r\n        if (!piece) {\r\n            continue\r\n        }\r\n        const sub = piece.split(';')\r\n        const token = sub[0]?.trim()?.toLowerCase()\r\n        if (!token) {\r\n            continue\r\n        }\r\n        let q = 1\r\n        for (let i = 1; i < sub.length; i++) {\r\n            const [k, v] = sub[i]!.split('=').map(s => s.trim())\r\n            if (k && k.toLowerCase() === 'q') {\r\n                const n = Number(v)\r\n                if (!Number.isNaN(n)) {\r\n                    q = n\r\n                }\r\n            }\r\n        }\r\n        out.set(token, q)\r\n    }\r\n    return out\r\n}\r\n\r\nasync function trySiblingCompressed(\r\n    abs: string,\r\n    prefer: Encoding[],\r\n    accept: Map<string, number>\r\n): Promise<{ path: string, encoding: Encoding }|null> {\r\n    for (const enc of prefer) {\r\n        const q = accept.get(enc)\r\n        if (q === 0) {\r\n            continue\r\n        }\r\n        if (q === undefined && accept.size > 0) {\r\n            continue\r\n        }\r\n        const candidate = `${abs}.${enc === 'br' ? 'br' : 'gz'}`\r\n        try {\r\n            const st = await fsp.stat(candidate)\r\n            if (st.isFile()) {\r\n                return { path: candidate, encoding: enc }\r\n            }\r\n        } catch {}\r\n    }\r\n    return null\r\n}\r\n\r\nexport interface StaticRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx>\r\n{\r\n    type: 'STATIC'\r\n    methods?: ('GET'|'HEAD')[]\r\n}\r\n\r\nexport class StaticRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, StaticRule<Ctx>>\r\n{\r\n    readonly typeName = 'STATIC'\r\n\r\n    private readonly ct: ContentTypeMap\r\n    private readonly resolveCT?: StaticRouteOptions['resolveContentType']\r\n    private readonly defaultCT: string\r\n    private readonly defaultTextCharset: string | false\r\n\r\n    private readonly pre: NormalizedPrecompressed\r\n\r\n    constructor(private cfg: StaticRouteOptions) {\r\n        this.resolveCT = cfg.resolveContentType\r\n        this.ct = { ...BASE_CT, ...normalizeCTMap(cfg.contentTypes) }\r\n        this.defaultCT = cfg.defaultContentType ?? 'application/octet-stream'\r\n        this.defaultTextCharset = cfg.defaultTextCharset ?? 'utf-8'\r\n\r\n        const p = cfg.precompressed ?? {}\r\n        this.pre = {\r\n            enabled: p.enabled ?? false,\r\n            prefer: p.prefer ?? ['br', 'gzip'],\r\n            useSiblingFiles: p.useSiblingFiles ?? true,\r\n            resolver: p.resolver, // опційний\r\n            allowRangesForCompressed: p.allowRangesForCompressed ?? false,\r\n            alwaysSetVary: p.alwaysSetVary ?? true\r\n        }\r\n    }\r\n\r\n    addRule(_rule: StaticRule<Ctx>) {\r\n        // зазвичай 1 правило на індекс; pipes можна навісити глобально на Router або тут\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx> | null {\r\n        if (ctx.req.method !== 'GET' && ctx.req.method !== 'HEAD') {\r\n            return null\r\n        }\r\n        // Inspect the raw request URL to detect literal or percent-encoded traversal attempts\r\n        // (e.g. \"/../index.html\" or \"/%2e%2e/index.html\"). The ctx.url (WHATWG URL) may\r\n        // normalize dot segments; checking ctx.req.url preserves the original raw path.\r\n        const raw = String(ctx.req.url ?? '')\r\n        const rawPath = raw.split('?')[0]!.split('#')[0]!\r\n        let decodedRaw = rawPath\r\n        try {\r\n            decodedRaw = decodeURIComponent(rawPath)\r\n        } catch {}        \r\n        if (decodedRaw.split('/').includes('..')) {\r\n            return null\r\n        }\r\n\r\n        const abs = this.cfg.index.resolveUrl(ctx.url)\r\n        if (!abs) {\r\n            return null\r\n        }\r\n\r\n        return async (c: Ctx): Promise<void>  => {\r\n            const origStats = await fsp.stat(abs)\r\n            const origSize = origStats.size\r\n            const isHead = c.req.method === 'HEAD'\r\n\r\n            const ext = extname(abs).toLowerCase()\r\n            const resolvedMime =\r\n                this.resolveCT?.(ext, abs, origStats, c)\r\n                ?? this.ct[ext]\r\n                ?? this.defaultCT\r\n\r\n            c.header('X-Content-Type-Options', 'nosniff')\r\n            c.header('Last-Modified', origStats.mtime.toUTCString())\r\n            c.header('Content-Type', maybeAppendCharset(resolvedMime, this.defaultTextCharset))\r\n\r\n            let filePath = abs\r\n            let effStats = origStats\r\n            let encoding: Encoding|null = null\r\n\r\n            if (this.pre.enabled) {\r\n                const accept = parseAcceptEncoding(c.req.headers['accept-encoding'] as string|undefined)\r\n\r\n                if (this.pre.alwaysSetVary) {\r\n                    c.header('Vary', 'Accept-Encoding')\r\n                }\r\n\r\n                let resolved: { path: string, encoding: Encoding }|null = null\r\n                if (this.pre.resolver) {\r\n                    resolved = await this.pre.resolver(abs, c.req.headers['accept-encoding'] as string|undefined)\r\n                } else if (this.pre.useSiblingFiles && accept.size > 0) {\r\n                    // Only consider sibling precompressed files when the client explicitly\r\n                    // provided Accept-Encoding tokens. When the header is absent, prefer\r\n                    // serving the original file (tests expect this behavior).\r\n                    resolved = await trySiblingCompressed(abs, this.pre.prefer, accept)\r\n                }\r\n\r\n                if (resolved) {\r\n                    filePath = resolved.path\r\n                    encoding = resolved.encoding\r\n                    effStats = await fsp.stat(filePath)\r\n                    c.header('Content-Encoding', encoding)\r\n                }\r\n            }\r\n\r\n            const size = effStats.size\r\n            const etag = encoding\r\n                ? `W/\"${size}-${Math.trunc(effStats.mtimeMs)}-${encoding}\"`\r\n                : `W/\"${origSize}-${Math.trunc(origStats.mtimeMs)}\"`\r\n            c.header('ETag', etag)\r\n\r\n            const inm = c.req.headers['if-none-match'] as string|undefined\r\n            if (inm && inm === etag) {\r\n                c.status(304)\r\n                c.res.end()\r\n                return\r\n            }\r\n\r\n            if (!encoding || this.pre.allowRangesForCompressed) {\r\n                c.header('Accept-Ranges', 'bytes')\r\n                const range = c.req.headers['range'] as string|undefined\r\n                if (range && range.startsWith('bytes=')) {\r\n                    let [s, e] = range.slice(6).split('-')\r\n                    let start = s ? parseInt(s, 10) : 0\r\n                    let end = e ? parseInt(e, 10) : size - 1\r\n                    if (Number.isNaN(start)) {\r\n                        start = 0\r\n                    }\r\n                    if (Number.isNaN(end)) {\r\n                        end = size - 1\r\n                    }\r\n                    if (start > end || start >= size) {\r\n                        c.status(416).header('Content-Range', `bytes */${size}`)\r\n                        c.res.end()\r\n                        return\r\n                    }\r\n                    c.status(206).header('Content-Range', `bytes ${start}-${end}/${size}`)\r\n                    c.header('Content-Length', String(end - start + 1))\r\n                    if (isHead) {\r\n                        c.res.end()\r\n                        return\r\n                    }\r\n                    const rs = createReadStream(filePath, { start, end })\r\n                    rs.on('error', () => c.res.destroy())\r\n                    rs.pipe(c.res)\r\n                    return\r\n                }\r\n            } else {\r\n                c.header('Accept-Ranges', 'none')\r\n            }\r\n\r\n            c.status(200).header('Content-Length', String(size))\r\n            if (isHead) {\r\n                c.res.end()\r\n                return\r\n            }\r\n            const rs = createReadStream(filePath)\r\n            rs.on('error', () => c.res.destroy())\r\n            rs.pipe(c.res)\r\n        }\r\n    }\r\n}\r\n"],"names":["HttpException","statusCode","message","expose","headers","RequestContext","req","res","code","k","v","obj","s","limit","resolve","reject","chunks","size","done","fail","err","ok","c","raw","Router","opts","type","pipes","rule","typeName","rt","_omit","pureRule","rules","r","ctx","base","globalPipe","name","exec","e","StaticIndex","path","next","visitedDirs","rootReal","fsp","inRoot","p","basePrefix","walk","dirAbs","rel","depth","entries","dirReal","childAbs","childRel","lst","error","targetReal","st","urlPath","indexFile","indexFileFullUrl","url","pathname","abs","compose","handler","pipe","normalizePath","METHOD_ORDER","PathRouteType","methods","m","exe","key","i","set","method","getKey","getHandler","originalResEnd","chunk","allowed","allowList","ordered","allowHeader","arr","l","mid","BuiltinValidators","toValidator","spec","decodeSafe","parsePattern","pattern","constraints","clean","parts","tokens","seg","validate","Node","n","PatternRouteType","node","t","h","params","go","idx","segRaw","segDec","pnode","acc","d","found","BASE_CT","normalizeCTMap","src","out","maybeAppendCharset","mime","charset","parseAcceptEncoding","piece","sub","token","q","trySiblingCompressed","prefer","accept","enc","candidate","StaticRouteType","cfg","_rule","rawPath","decodedRaw","origStats","origSize","isHead","ext","extname","resolvedMime","filePath","effStats","encoding","resolved","etag","inm","range","start","end","rs","createReadStream"],"mappings":"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"}