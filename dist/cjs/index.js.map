{"version":3,"file":"index.js","sources":["../../src/core/HttpException.ts","../../src/core/http.ts","../../src/core/Router.ts","../../src/services/StaticIndex.ts","../../src/route-types/PathRouteType.ts","../../src/route-types/StaticRouteType.ts"],"sourcesContent":["export class HttpException extends Error {\r\n    constructor(\r\n        public statusCode: number,\r\n        message = 'Http Error',\r\n        public expose = statusCode < 500,\r\n        public headers: Record<string, string> = {}\r\n    ) { \r\n        super(message) \r\n    }\r\n}\r\n","import type { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { HttpException } from './HttpException.js'\r\n\r\nexport type Method =\r\n    | 'GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'\r\n\r\nexport class RequestContext {\r\n\r\n    constructor(\r\n        public req: IncomingMessage,\r\n        public res: ServerResponse,\r\n    ) {}\r\n\r\n    url!: URL; // fill in router\r\n    params: Record<string,string> = Object.create(null)\r\n    locals: Record<string, unknown> = Object.create(null)\r\n\r\n    // Configurable limits\r\n    limits = { \r\n        bodySize: 16 * 1024, \r\n        headerTimeoutMs: 30_000, \r\n        requestTimeoutMs: 60_000 \r\n    }\r\n\r\n    // response API \r\n    status(code: number) { \r\n        this.res.statusCode = code\r\n        return this\r\n    }\r\n\r\n    header(k: string, v: string) { \r\n        this.res.setHeader(k, v)\r\n        return this\r\n    }\r\n\r\n    json(obj: unknown) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n        } \r\n        this.res.end(JSON.stringify(obj))\r\n    }\r\n\r\n    text(s: string) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'text/plain; charset=utf-8')\r\n        }\r\n        this.res.end(s)\r\n    }\r\n\r\n    // Request body with limit and abort-safe\r\n    async bodyRaw(limit = this.limits.bodySize): Promise<Buffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const chunks: Buffer[] = []\r\n            let size = 0, done = false\r\n            const fail = (err: Error) => { \r\n                if (!done) { \r\n                    done = true\r\n                    this.req.destroy()\r\n                    reject(err)\r\n                }\r\n            }\r\n            const ok = () => {\r\n                if (!done) {\r\n                    done = true\r\n                    resolve(Buffer.concat(chunks))\r\n                }\r\n            }\r\n\r\n            this.req.once('error', fail)\r\n            this.req.once('aborted', () => fail(new HttpException(499, 'Client Closed Request', true)))\r\n            this.req.on('data', (c: Buffer) => {\r\n                size += c.length\r\n                if (size > limit) return fail(new HttpException(413, 'Content Too Large', true))\r\n                chunks.push(c)\r\n            })\r\n            this.req.once('end', ok)\r\n        })\r\n    }\r\n\r\n    async bodyJson<T = unknown>(limit?: number): Promise<T> {\r\n        const raw = await this.bodyRaw(limit);\r\n        try { \r\n            return JSON.parse(raw.toString('utf8')) as T\r\n        }\r\n        catch { \r\n            throw new HttpException(400, 'Invalid JSON', true)\r\n        }\r\n    }\r\n}\r\n\r\nexport type Handler<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport type Pipe<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport interface RouteRuleBase<Ctx extends RequestContext = RequestContext> {\r\n    handler: Handler<Ctx>\r\n    pipes?: readonly Pipe<Ctx>[]\r\n}\r\n\r\nexport interface IRouteType<\r\n    Ctx extends RequestContext = RequestContext,\r\n    TRule extends RouteRuleBase<Ctx> = RouteRuleBase<Ctx>\r\n> {\r\n    readonly typeName: string\r\n    addRule(rule: TRule): void\r\n    match(ctx: Ctx): ((ctx: Ctx) => void | Promise<void>) | null\r\n}","import { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { HttpException } from './HttpException.js'\r\nimport { RequestContext, Pipe, IRouteType, RouteRuleBase } from './http.js'\r\n\r\ntype TypeNameOf<T> = T extends { typeName: infer N extends string } ? N : never\r\ntype RuleOf<T>     = T extends IRouteType<any, infer R> ? R : never\r\n\r\ntype Registry<Ctx extends RequestContext> = Record<string, IRouteType<Ctx, any>>\r\ntype DiscriminatedRuleUnion<TReg extends Registry<any>> =\r\n    { [K in keyof TReg]:\r\n        RuleOf<TReg[K]> & { type: K & string }\r\n    }[keyof TReg]\r\n\r\n    \r\ntype CtxFactory<Ctx extends RequestContext> =\r\n    | { class: new (req: IncomingMessage, res: ServerResponse) => Ctx, factory?: never }\r\n    | { factory: (req: IncomingMessage, res: ServerResponse) => Ctx, class?: never }\r\n    | undefined\r\n\r\nexport class Router <\r\n    Ctx extends RequestContext = RequestContext,\r\n    TReg extends Registry<Ctx> = {}\r\n> {\r\n    private reg: TReg\r\n    private order: string[] = []\r\n    private ctxFactory?: CtxFactory<Ctx>\r\n    private globalPipes: Array<(ctx: Ctx)=>void|Promise<void>> = []\r\n\r\n    constructor(opts?: { context?: CtxFactory<Ctx> }) {\r\n        this.reg = {} as TReg\r\n        this.ctxFactory = opts?.context\r\n    }\r\n\r\n\r\n    useType<K extends string, T extends IRouteType<Ctx, any> & { typeName: K }>(\r\n        type: T\r\n    ): Router<Ctx, TReg & Record<K, T>> {\r\n        (this.reg as any)[type.typeName] = type\r\n        this.order.push(type.typeName)\r\n        return this as any\r\n    }\r\n\r\n    useGlobalPipes(...pipes: Pipe<Ctx>[]) {\r\n        this.globalPipes.push(...pipes)\r\n        return this\r\n    }\r\n\r\n    addRule(rule: DiscriminatedRuleUnion<TReg>) {\r\n        const t = (this.reg as any)[rule.type] as IRouteType<Ctx, RouteRuleBase<Ctx>> | undefined\r\n        if (!t) throw new Error(`Route type \"${rule.type}\" is not registered`)\r\n        \r\n        const { type: _omit, ...pureRule } = rule as any\r\n        t.addRule(pureRule)\r\n        return this\r\n    }\r\n\r\n    addRules(rules: Array<DiscriminatedRuleUnion<TReg>>) {\r\n        for (const r of rules) this.addRule(r)\r\n        return this\r\n    }\r\n\r\n    private makeCtx(req: IncomingMessage, res: ServerResponse): Ctx {\r\n        if (this.ctxFactory?.factory) return this.ctxFactory.factory(req, res)\r\n        if (this.ctxFactory?.class)   return new this.ctxFactory.class(req, res)\r\n        return new RequestContext(req, res) as Ctx\r\n    }\r\n\r\n    // Main server request handler\r\n    async handler(req: IncomingMessage, res: ServerResponse) {\r\n        const ctx = this.makeCtx(req, res)\r\n        const base = 'http://' + (req.headers.host || 'localhost')\r\n        ctx.url = new URL(req.url || '/', base)\r\n\r\n        try {\r\n            for (const globalPipe of this.globalPipes) {\r\n                await globalPipe(ctx)\r\n            }\r\n\r\n            for (const name of this.order) {\r\n                const routeType = (this.reg as any)[name] as IRouteType<Ctx, any>\r\n                const exec = routeType.match(ctx)\r\n                if (exec) {\r\n                    return await exec(ctx)\r\n                }\r\n            }\r\n\r\n            res.statusCode = 404\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: 'Not Found' }))\r\n        } catch (e: any) {\r\n            const code = e?.statusCode ?? 500\r\n            res.statusCode = code\r\n            if (e?.headers) for (const [k, v] of Object.entries(e.headers)) res.setHeader(k, String(v))\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: e?.expose ? e.message : 'Internal Server Error' }))\r\n        }\r\n    }\r\n}\r\n","// static-index.ts\r\nimport { promises as fsp } from 'node:fs'\r\nimport path from 'node:path'\r\n\r\nexport interface StaticIndexOptions {\r\n    rootDir: string\r\n    urlBase: string\r\n    scanIntervalMs?: number\r\n    followSymlinks?: boolean\r\n}\r\n\r\nexport class StaticIndex {\r\n    private map = new Map<string,string>() // \"/static/a/b.js\" => \"/abs/a/b.js\"\r\n    private root!: string\r\n    private base!: string\r\n    private timer?: NodeJS.Timeout\r\n\r\n    constructor(private opts: StaticIndexOptions) {\r\n        this.root = path.resolve(opts.rootDir)\r\n        this.base = opts.urlBase.endsWith('/') ? opts.urlBase.slice(0,-1) : opts.urlBase\r\n    }\r\n\r\n    start() {\r\n        this.rebuild().catch(()=>{})\r\n        if (this.opts.scanIntervalMs) {\r\n            this.timer = setInterval(() => this.rebuild().catch(()=>{}), this.opts.scanIntervalMs).unref()\r\n        }\r\n    }\r\n\r\n    stop() { \r\n        if (this.timer) clearInterval(this.timer)\r\n    }\r\n\r\n    // O(#files). Для великих дерев — інкрементал або шардінг по підкаталогах\r\n    private async rebuild() {\r\n        const next = new Map<string,string>()\r\n        const walk = async (dirAbs: string, rel: string) => {\r\n            const entries = await fsp.readdir(dirAbs, { withFileTypes: true })\r\n            for (const e of entries) {\r\n                const name = e.name;\r\n                if (name.startsWith('.')) {\r\n                    continue // ховаємо dotfiles\r\n                }\r\n                const childAbs = path.join(dirAbs, name)\r\n                const childRel = rel ? rel + '/' + name : name\r\n                if (e.isDirectory()) {\r\n                    await walk(childAbs, childRel)\r\n                } else if (e.isFile()) {\r\n                    const urlPath = this.base + '/' + childRel.replace(/\\\\/g,'/')\r\n                    next.set(urlPath, childAbs)\r\n                }\r\n            }\r\n        }\r\n        await walk(this.root, '')\r\n        // Атомарна заміна, читачі користуються \"map\"\r\n        this.map = next\r\n    }\r\n\r\n    lookup(urlPath: string): string | undefined {\r\n        return this.map.get(urlPath)\r\n    }\r\n\r\n    resolveUrl(url: URL): string | undefined {\r\n        const pathname = url.pathname\r\n        if (!(pathname === this.base || pathname.startsWith(this.base + '/'))) {\r\n            return undefined\r\n        }\r\n        const abs = this.lookup(pathname)\r\n        // додатковий рантайм-захист від traversal (хоч ми індексуємо, все одно перевіримо):\r\n        if (abs && abs.startsWith(this.root)) {\r\n            return abs\r\n        }\r\n        return undefined\r\n    }\r\n}\r\n","\r\nimport { IRouteType, RouteRuleBase, Pipe, RequestContext, Handler } from '../core/http.js'\r\n\r\nexport interface PathRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx> \r\n{\r\n    path: string\r\n    methods?: ('GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS')[]\r\n}\r\n\r\nfunction compose<Ctx extends RequestContext = RequestContext>(pipes: readonly Pipe<Ctx>[] | undefined, handler: Handler<Ctx>): Handler<Ctx> {\r\n    if (!pipes || pipes.length === 0) return handler\r\n    // flat loop for — minimal overhead\r\n    return async (ctx: Ctx) => {\r\n        for (const pipe of pipes) { \r\n            await pipe(ctx)\r\n        }\r\n        return handler(ctx)\r\n    }\r\n}\r\n\r\nexport class PathRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, PathRule<Ctx>> \r\n{  \r\n    readonly typeName = 'PATH' as const\r\n    private keys: string[] = []  // \"GET /health\"   (upper method)\r\n    private execs: Handler<Ctx>[] = []\r\n\r\n    addRule(rule: PathRule<Ctx>): void {\r\n        const methods = rule.methods?.length ? rule.methods : ['GET','HEAD','POST','PUT','PATCH','DELETE','OPTIONS']\r\n        const exe = compose(rule.pipes, rule.handler)\r\n        for (const m of methods) {\r\n            const key = `${m} ${rule.path}`            \r\n            let i = this.lowerBound(this.keys, key)\r\n            this.keys.splice(i, 0, key)\r\n            this.execs.splice(i, 0, exe)\r\n        }\r\n    }\r\n\r\n    match(ctx: RequestContext): Handler<Ctx> | null {\r\n        const method = (ctx.req.method || 'GET').toUpperCase()\r\n        const key = `${method} ${ctx.url.pathname.replace(/\\/$/, '') || '/'}`;\r\n        const i = this.lowerBound(this.keys, key);\r\n        return (i < this.keys.length && this.keys[i] === key) \r\n            ? this.execs[i]!\r\n            : null\r\n    }\r\n\r\n    private lowerBound(arr: string[], key: string): number {\r\n        let l = 0, r = arr.length;\r\n        while(l < r) { \r\n            const mid = (l + r >>> 1)\r\n            if (arr[mid]! < key) {\r\n                l = mid + 1\r\n            } else {\r\n                r = mid\r\n            }\r\n        }\r\n        return l\r\n    }\r\n}\r\n","import { createReadStream, promises as fsp } from 'node:fs'\r\nimport { extname } from 'node:path'\r\n\r\nimport { RequestContext, IRouteType, RouteRuleBase, Handler } from '../core/http.js'\r\n\r\nimport { StaticIndex } from '../services/StaticIndex.js'\r\n\r\nconst CT: Record<string,string> = {\r\n    '.html':'text/html; charset=utf-8', '.json':'application/json; charset=utf-8', '.txt':'text/plain; charset=utf-8',\r\n    '.js':'application/javascript; charset=utf-8', '.css':'text/css; charset=utf-8',\r\n    '.png':'image/png', '.jpg':'image/jpeg', '.jpeg':'image/jpeg', '.webp':'image/webp', '.gif':'image/gif', '.svg':'image/svg+xml',\r\n    '.mp4':'video/mp4', '.webm':'video/webm', '.mp3':'audio/mpeg', '.wav':'audio/wav',\r\n};\r\n\r\nexport interface StaticRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx> \r\n{\r\n    methods?: ('GET'|'HEAD')[]\r\n}\r\n\r\n\r\nexport class StaticRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, StaticRule<Ctx>> \r\n{\r\n    readonly typeName = 'STATIC' as const\r\n    constructor(private cfg: { index: StaticIndex }) {}\r\n\r\n    addRule(_rule: StaticRule<Ctx>): void {\r\n        // для STATIC зазвичай 1 правило на індекс; pipes можна навісити глобально на Router або тут\r\n    }\r\n\r\n    match(ctx: RequestContext): Handler<Ctx> | null {\r\n        if (ctx.req.method !== 'GET' && ctx.req.method !== 'HEAD') {\r\n            return null\r\n        }\r\n        const abs = this.cfg.index.resolveUrl(ctx.url)\r\n        if (!abs) return null\r\n\r\n        return async (c: RequestContext): Promise<void>  => {\r\n            const stats = await fsp.stat(abs)\r\n            const size = stats.size\r\n            const isHead = c.req.method === 'HEAD'\r\n\r\n            const ext = extname(abs).toLowerCase()\r\n            c.header('X-Content-Type-Options', 'nosniff')\r\n            c.header('Accept-Ranges', 'bytes')\r\n            c.header('Last-Modified', stats.mtime.toUTCString())\r\n            c.header('Content-Type', CT[ext] || 'application/octet-stream')\r\n\r\n            // ETag слабкий: W/\"size-mtimeMs\"\r\n            const etag = `W/\"${size}-${Math.trunc(stats.mtimeMs)}\"`\r\n            c.header('ETag', etag)\r\n            if (c.req.headers['if-none-match'] === etag) { \r\n                c.status(304)\r\n                c.res.end()\r\n                return\r\n            }\r\n\r\n            const range = c.req.headers['range']\r\n            if (range && range.startsWith('bytes=')) {\r\n                let [s, e] = range.slice(6).split('-')\r\n                let start = s ? parseInt(s, 10) : 0\r\n                let end = e ? parseInt(e, 10) : size - 1\r\n                if (Number.isNaN(start)) start = 0\r\n                if (Number.isNaN(end)) end = size - 1\r\n                if (start > end || start >= size) {\r\n                    c.status(416).header('Content-Range', `bytes */${size}`)\r\n                    c.res.end()\r\n                    return\r\n                }\r\n                c.status(206).header('Content-Range', `bytes ${start}-${end}/${size}`)\r\n                c.header('Content-Length', String(end - start + 1))\r\n                if (isHead) {\r\n                    c.res.end()\r\n                    return\r\n                }\r\n                const rs = createReadStream(abs, { start, end })\r\n                rs.on('error', () => c.res.destroy())\r\n                rs.pipe(c.res)\r\n                return\r\n            }\r\n\r\n            c.status(200).header('Content-Length', String(size))\r\n            if (isHead) {\r\n                c.res.end()\r\n                return \r\n            }\r\n            const rs = createReadStream(abs)\r\n            rs.on('error', () => c.res.destroy())\r\n            rs.pipe(c.res)\r\n        }\r\n    }\r\n}\r\n"],"names":["HttpException","statusCode","message","expose","headers","RequestContext","req","res","code","k","v","obj","s","limit","resolve","reject","chunks","size","done","fail","err","ok","c","raw","Router","opts","type","pipes","rule","t","_omit","pureRule","rules","r","ctx","base","globalPipe","name","exec","e","StaticIndex","path","next","walk","dirAbs","rel","entries","fsp","childAbs","childRel","urlPath","url","pathname","abs","compose","handler","pipe","PathRouteType","methods","exe","m","key","i","arr","l","mid","CT","StaticRouteType","cfg","_rule","stats","isHead","ext","extname","etag","range","start","end","rs","createReadStream"],"mappings":"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"}