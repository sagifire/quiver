{"version":3,"file":"index.js","sources":["../../src/core/HttpException.ts","../../src/core/http.ts","../../src/core/Router.ts","../../src/services/StaticIndex.ts","../../src/route-types/PathRouteType.ts","../../src/core/compose.ts","../../src/route-types/PatternRouteType.ts","../../src/route-types/StaticRouteType.ts"],"sourcesContent":["export class HttpException extends Error {\r\n    constructor(\r\n        public statusCode: number,\r\n        message = 'Http Error',\r\n        public expose = statusCode < 500,\r\n        public headers: Record<string, string> = {}\r\n    ) { \r\n        super(message) \r\n    }\r\n}\r\n","import type { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { HttpException } from './HttpException.js'\r\n\r\nexport type Method =\r\n    | 'GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'\r\n\r\nexport class RequestContext {\r\n\r\n    constructor(\r\n        public req: IncomingMessage,\r\n        public res: ServerResponse,\r\n    ) {}\r\n\r\n    url!: URL; // fill in router\r\n    params: Record<string,string> = Object.create(null)\r\n    locals: Record<string, unknown> = Object.create(null)\r\n\r\n    // Configurable limits\r\n    limits = { \r\n        bodySize: 16 * 1024, \r\n        headerTimeoutMs: 30_000, \r\n        requestTimeoutMs: 60_000 \r\n    }\r\n\r\n    // response API \r\n    status(code: number) { \r\n        this.res.statusCode = code\r\n        return this\r\n    }\r\n\r\n    header(k: string, v: string) { \r\n        this.res.setHeader(k, v)\r\n        return this\r\n    }\r\n\r\n    json(obj: unknown) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n        } \r\n        this.res.end(JSON.stringify(obj))\r\n    }\r\n\r\n    text(s: string) {\r\n        if (!this.res.hasHeader('Content-Type')) {\r\n            this.res.setHeader('Content-Type', 'text/plain; charset=utf-8')\r\n        }\r\n        this.res.end(s)\r\n    }\r\n\r\n    // Request body with limit and abort-safe\r\n    async bodyRaw(limit = this.limits.bodySize): Promise<Buffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const chunks: Buffer[] = []\r\n            let size = 0, done = false\r\n            const fail = (err: Error) => { \r\n                if (!done) { \r\n                    done = true\r\n                    this.req.destroy()\r\n                    reject(err)\r\n                }\r\n            }\r\n            const ok = () => {\r\n                if (!done) {\r\n                    done = true\r\n                    resolve(Buffer.concat(chunks))\r\n                }\r\n            }\r\n\r\n            this.req.once('error', fail)\r\n            this.req.once('aborted', () => fail(new HttpException(499, 'Client Closed Request', true)))\r\n            this.req.on('data', (c: Buffer) => {\r\n                size += c.length\r\n                if (size > limit) return fail(new HttpException(413, 'Content Too Large', true))\r\n                chunks.push(c)\r\n            })\r\n            this.req.once('end', ok)\r\n        })\r\n    }\r\n\r\n    async bodyJson<T = unknown>(limit?: number): Promise<T> {\r\n        const raw = await this.bodyRaw(limit);\r\n        try { \r\n            return JSON.parse(raw.toString('utf8')) as T\r\n        }\r\n        catch { \r\n            throw new HttpException(400, 'Invalid JSON', true)\r\n        }\r\n    }\r\n}\r\n\r\nexport type Handler<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport type Pipe<Ctx extends RequestContext = RequestContext> =\r\n    (ctx: Ctx) => void | Promise<void>\r\n\r\nexport interface RouteRuleBase<Ctx extends RequestContext = RequestContext> {\r\n    handler: Handler<Ctx>\r\n    pipes?: readonly Pipe<Ctx>[]\r\n}\r\n\r\nexport interface IRouteType<\r\n    Ctx extends RequestContext = RequestContext,\r\n    TRule extends RouteRuleBase<Ctx> = RouteRuleBase<Ctx>\r\n> {\r\n    readonly typeName: string\r\n    addRule(rule: TRule): void\r\n    match(ctx: Ctx): ((ctx: Ctx) => void | Promise<void>) | null\r\n}","import { IncomingMessage, ServerResponse } from 'node:http'\r\n\r\nimport { HttpException } from './HttpException.js'\r\nimport { RequestContext, Pipe, IRouteType, RouteRuleBase } from './http.js'\r\n\r\ntype TypeNameOf<T> = T extends { typeName: infer N extends string } ? N : never\r\ntype RuleOf<T>     = T extends IRouteType<any, infer R> ? R : never\r\n\r\ntype Registry<Ctx extends RequestContext> = Record<string, IRouteType<Ctx, any>>\r\ntype DiscriminatedRuleUnion<TReg extends Registry<any>> =\r\n    { [K in keyof TReg]:\r\n        RuleOf<TReg[K]> & { type: K & string }\r\n    }[keyof TReg]\r\n\r\n    \r\ntype CtxFactory<Ctx extends RequestContext> =\r\n    | { class: new (req: IncomingMessage, res: ServerResponse) => Ctx, factory?: never }\r\n    | { factory: (req: IncomingMessage, res: ServerResponse) => Ctx, class?: never }\r\n    | undefined\r\n\r\nexport class Router <\r\n    Ctx extends RequestContext = RequestContext,\r\n    TReg extends Registry<Ctx> = {}\r\n> {\r\n    private reg: TReg\r\n    private order: string[] = []\r\n    private ctxFactory?: CtxFactory<Ctx>\r\n    private globalPipes: Array<(ctx: Ctx)=>void|Promise<void>> = []\r\n\r\n    constructor(opts?: { context?: CtxFactory<Ctx> }) {\r\n        this.reg = {} as TReg\r\n        this.ctxFactory = opts?.context\r\n    }\r\n\r\n\r\n    useType<K extends string, T extends IRouteType<Ctx, any> & { typeName: K }>(\r\n        type: T\r\n    ): Router<Ctx, TReg & Record<K, T>> {\r\n        (this.reg as any)[type.typeName] = type\r\n        this.order.push(type.typeName)\r\n        return this as any\r\n    }\r\n\r\n    useGlobalPipes(...pipes: Pipe<Ctx>[]) {\r\n        this.globalPipes.push(...pipes)\r\n        return this\r\n    }\r\n\r\n    addRule(rule: DiscriminatedRuleUnion<TReg>) {\r\n        const t = (this.reg as any)[rule.type] as IRouteType<Ctx, RouteRuleBase<Ctx>> | undefined\r\n        if (!t) throw new Error(`Route type \"${rule.type}\" is not registered`)\r\n        \r\n        const { type: _omit, ...pureRule } = rule as any\r\n        t.addRule(pureRule)\r\n        return this\r\n    }\r\n\r\n    addRules(rules: Array<DiscriminatedRuleUnion<TReg>>) {\r\n        for (const r of rules) this.addRule(r)\r\n        return this\r\n    }\r\n\r\n    private makeCtx(req: IncomingMessage, res: ServerResponse): Ctx {\r\n        if (this.ctxFactory?.factory) return this.ctxFactory.factory(req, res)\r\n        if (this.ctxFactory?.class)   return new this.ctxFactory.class(req, res)\r\n        return new RequestContext(req, res) as Ctx\r\n    }\r\n\r\n    // Main server request handler\r\n    async handler(req: IncomingMessage, res: ServerResponse) {\r\n        const ctx = this.makeCtx(req, res)\r\n        const base = 'http://' + (req.headers.host || 'localhost')\r\n        ctx.url = new URL(req.url || '/', base)\r\n\r\n        try {\r\n            for (const globalPipe of this.globalPipes) {\r\n                await globalPipe(ctx)\r\n            }\r\n\r\n            for (const name of this.order) {\r\n                const routeType = (this.reg as any)[name] as IRouteType<Ctx, any>\r\n                const exec = routeType.match(ctx)\r\n                if (exec) {\r\n                    return await exec(ctx)\r\n                }\r\n            }\r\n\r\n            res.statusCode = 404\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: 'Not Found' }))\r\n        } catch (e: any) {\r\n            const code = e?.statusCode ?? 500\r\n            res.statusCode = code\r\n            if (e?.headers) for (const [k, v] of Object.entries(e.headers)) res.setHeader(k, String(v))\r\n            res.setHeader('Content-Type', 'application/json; charset=utf-8')\r\n            res.end(JSON.stringify({ error: e?.expose ? e.message : 'Internal Server Error' }))\r\n        }\r\n    }\r\n}\r\n","// static-index.ts\r\nimport { promises as fsp, Dirent, Stats } from 'node:fs'\r\nimport path from 'node:path'\r\n\r\nexport interface StaticIndexOptions {\r\n    rootDir: string\r\n    urlBase: string\r\n    scanIntervalMs?: number\r\n    followSymlinks?: boolean\r\n    maxFiles?: number\r\n    maxDepth?: number\r\n    allowWellKnown?: boolean\r\n    logger?: {\r\n        warn: (...params:any[]) => void\r\n        debug: (...params:any[]) => void\r\n    }\r\n}\r\n\r\nexport class StaticIndex {\r\n    private map = new Map<string,string>() // \"/static/a/b.js\" => \"/abs/a/b.js\"\r\n    private root!: string\r\n    private base!: string\r\n    private timer?: NodeJS.Timeout\r\n\r\n    constructor(private opts: StaticIndexOptions) {\r\n        this.root = path.resolve(opts.rootDir)\r\n        this.base = opts.urlBase.endsWith('/') ? opts.urlBase.slice(0,-1) : opts.urlBase\r\n    }\r\n\r\n    start() {\r\n        this.rebuild().catch(()=>{})\r\n        if (this.opts.scanIntervalMs) {\r\n            this.timer = setInterval(() => this.rebuild().catch(()=>{}), this.opts.scanIntervalMs).unref()\r\n        }\r\n    }\r\n\r\n    stop() { \r\n        if (this.timer) clearInterval(this.timer)\r\n    }\r\n\r\n    // O(#files). Для великих дерев — інкрементал або шардінг по підкаталогах\r\n    private async rebuild() {\r\n        const next = new Map<string, string>()\r\n        const visitedDirs = new Set<string>()\r\n\r\n        // 1) Real root\r\n        const rootReal = await fsp.realpath(this.root).catch(() => this.root)\r\n\r\n        const inRoot = (p: string) =>\r\n            p === rootReal || p.startsWith(rootReal + path.sep)\r\n\r\n        const walk = async (dirAbs: string, rel: string, depth = 0) => {\r\n            // (optional) depth limit\r\n            if (this.opts.maxDepth && depth > this.opts.maxDepth) {\r\n                return\r\n            }\r\n\r\n            let entries: Dirent[]\r\n            try {\r\n                entries = await fsp.readdir(dirAbs, { withFileTypes: true })\r\n            } catch (err) {\r\n                this.opts.logger?.warn?.(`readdir failed: ${dirAbs}`, err)\r\n                return\r\n            }\r\n\r\n            // loop protection \r\n            let dirReal = await fsp.realpath(dirAbs).catch(() => dirAbs)\r\n            if (!inRoot(dirReal)) return; // don't index files without root\r\n            if (visitedDirs.has(dirReal)) {\r\n                return\r\n            }\r\n            visitedDirs.add(dirReal)\r\n\r\n            for (const e of entries) {\r\n                const name = e.name\r\n                if (name.startsWith('.')) {\r\n                    if (!(this.opts.allowWellKnown && name === '.well-known')) {\r\n                        continue\r\n                    }\r\n                }\r\n\r\n                const childAbs = path.join(dirAbs, name)\r\n                const childRel = rel ? rel + '/' + name : name\r\n\r\n                let lst: Stats\r\n                try {\r\n                    lst = await fsp.lstat(childAbs) // without transition\r\n                } catch (error) {\r\n                    this.opts.logger?.debug?.(`lstat failed: ${childAbs}`, error)\r\n                    continue\r\n                }\r\n\r\n                // Symlink\r\n                if (lst.isSymbolicLink()) {\r\n                    if (!this.opts.followSymlinks) continue\r\n                    let targetReal: string\r\n                    try {\r\n                        targetReal = await fsp.realpath(childAbs)\r\n                    } catch (error) {\r\n                        this.opts.logger?.debug?.(`realpath failed: ${childAbs}`, error)\r\n                        continue;\r\n                    }\r\n                    if (!inRoot(targetReal)) {\r\n                        continue\r\n                    }\r\n\r\n                    // Classifying the target\r\n                    let st: Stats\r\n                    try {\r\n                        st = await fsp.stat(childAbs)\r\n                    } catch (error) {\r\n                        this.opts.logger?.debug?.(`stat failed: ${childAbs}`, error)\r\n                        continue\r\n                    }\r\n                    if (st.isDirectory()) {\r\n                        await walk(childAbs, childRel, depth + 1)\r\n                    } else if (st.isFile()) {\r\n                        const urlPath = `${this.base}/${childRel.split(path.sep).join('/')}`\r\n                        next.set(urlPath, childAbs); // save the path via link — ok\r\n                    }\r\n                    continue\r\n                }\r\n\r\n                // Normal files/directories\r\n                if (lst.isDirectory()) {\r\n                    await walk(childAbs, childRel, depth + 1)\r\n                } else if (lst.isFile()) {\r\n                    const urlPath = `${this.base}/${childRel.split(path.sep).join('/')}`\r\n                    next.set(urlPath, childAbs)\r\n                }\r\n                // other types — ignore\r\n            }\r\n        };\r\n\r\n        await walk(this.root, '')\r\n\r\n        // (optional) quantity limit\r\n        if (this.opts.maxFiles && next.size > this.opts.maxFiles) {\r\n            this.opts.logger?.warn?.(`file index truncated: ${next.size} > ${this.opts.maxFiles}`)\r\n        }\r\n\r\n        this.map = next // atomic replacement\r\n    }\r\n\r\n    lookup(urlPath: string): string | undefined {\r\n        return this.map.get(urlPath)\r\n    }\r\n\r\n    resolveUrl(url: URL): string | undefined {\r\n        const pathname = url.pathname\r\n        if (!(pathname === this.base || pathname.startsWith(this.base + '/'))) {\r\n            return undefined\r\n        }\r\n        const abs = this.lookup(pathname)\r\n        // додатковий рантайм-захист від traversal (хоч ми індексуємо, все одно перевіримо):\r\n        if (abs && abs.startsWith(this.root)) {\r\n            return abs\r\n        }\r\n        return undefined\r\n    }\r\n}\r\n","import { IRouteType, RouteRuleBase, Pipe, RequestContext, Handler } from '../core/http.js'\r\nimport { HttpException } from '../core/HttpException.js'\r\n\r\nexport interface PathRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx>\r\n{\r\n    path: string\r\n    methods?: ('GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS')[]\r\n}\r\n\r\nfunction compose<Ctx extends RequestContext = RequestContext>(pipes: readonly Pipe<Ctx>[]|undefined, handler: Handler<Ctx>): Handler<Ctx> {\r\n    if (!pipes || pipes.length === 0) {\r\n        return handler\r\n    }\r\n    return async (ctx: Ctx) => {\r\n        for (const pipe of pipes) {\r\n            await pipe(ctx)\r\n        }\r\n        return handler(ctx)\r\n    }\r\n}\r\n\r\nfunction normalizePath(p: string) {\r\n    if (!p || p === '/') {\r\n        return '/'\r\n    }\r\n    return p.endsWith('/') ? p.slice(0, -1) : p\r\n}\r\n\r\nconst METHOD_ORDER: ReadonlyArray<string> = ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']\r\n\r\nexport class PathRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, PathRule<Ctx>>\r\n{\r\n    readonly typeName = 'PATH' as const\r\n\r\n    // Бінарний пошук по \"METHOD␠PATH\"\r\n    private keys: string[] = []\r\n    private execs: Handler<Ctx>[] = []\r\n\r\n    // Для 405: індекс шлях → множина дозволених методів\r\n    private pathMethods = new Map<string, Set<string>>()\r\n\r\n    addRule(rule: PathRule<Ctx>) {\r\n        const path = normalizePath(rule.path)\r\n        const methods = (rule.methods?.length ? rule.methods : ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'])\r\n            .map(m => m.toUpperCase())\r\n\r\n        const exe = compose(rule.pipes, rule.handler)\r\n\r\n        for (const m of methods) {\r\n            const key = `${m} ${path}`\r\n            const i = this.lowerBound(this.keys, key)\r\n            this.keys.splice(i, 0, key)\r\n            this.execs.splice(i, 0, exe)\r\n        }\r\n\r\n        let set = this.pathMethods.get(path)\r\n        if (!set) {\r\n            set = new Set<string>()\r\n            this.pathMethods.set(path, set)\r\n        }\r\n        for (const m of methods) {\r\n            set.add(m)\r\n        }\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx>|null {\r\n        const method = (ctx.req.method || 'GET').toUpperCase()\r\n        const path = normalizePath(ctx.url.pathname)\r\n        const key = `${method} ${path}`\r\n\r\n        // 1) Точний збіг: METHOD + PATH\r\n        let i = this.lowerBound(this.keys, key)\r\n        if (i < this.keys.length && this.keys[i] === key) {\r\n            return this.execs[i]!\r\n        }\r\n\r\n        // 2) HEAD → fallback на GET, якщо HEAD не знайдено, але GET існує\r\n        if (method === 'HEAD') {\r\n            const getKey = `GET ${path}`\r\n            i = this.lowerBound(this.keys, getKey)\r\n            if (i < this.keys.length && this.keys[i] === getKey) {\r\n                const getHandler = this.execs[i]!;\r\n                return async (ctx: Ctx) => {\r\n                    // Зберігаємо оригінальний res.end\r\n                    const originalResEnd = ctx.res.end;\r\n                    // Тимчасово перевизначаємо res.end, щоб придушити тіло для HEAD запитів\r\n                    ctx.res.end = (chunk?: any) => {\r\n                        // Нічого не робимо з chunk, просто повертаємо res\r\n                        return ctx.res;\r\n                    };\r\n\r\n                    await getHandler(ctx); // Виконуємо GET обробник для побічних ефектів (наприклад, встановлення заголовків)\r\n\r\n                    // Відновлюємо оригінальний res.end\r\n                    ctx.res.end = originalResEnd;\r\n\r\n                    // Явно встановлюємо статус та завершуємо відповідь для HEAD\r\n                    // Зберігаємо статус, якщо він був встановлений обробником, інакше 200\r\n                    ctx.res.statusCode = ctx.res.statusCode === 200 ? 200 : ctx.res.statusCode;\r\n                    ctx.res.end(); // Відправляємо порожнє тіло\r\n                };\r\n            }\r\n        }\r\n\r\n        // 3) Розрізнення 404 vs 405\r\n        const allowed = this.pathMethods.get(path)\r\n        if (allowed && allowed.size > 0) {\r\n            // RFC: якщо GET дозволено, HEAD теж вважається дозволеним → додамо у Allow\r\n            const allowList = new Set<string>(allowed)\r\n            if (allowed.has('GET')) {\r\n                allowList.add('HEAD')\r\n            }\r\n            const ordered = METHOD_ORDER.filter(m => allowList.has(m))\r\n            const allowHeader = ordered.length ? ordered.join(', ') : Array.from(allowList).join(', ')\r\n            return () => {\r\n                throw new HttpException(405, 'Method Not Allowed', true, { 'Allow': allowHeader })\r\n            }\r\n        }\r\n\r\n        // Інакше — шляху немає зовсім → 404 (Router відпрацює свій notFound)\r\n        return null\r\n    }\r\n\r\n    private lowerBound(arr: string[], key: string): number {\r\n        let l = 0\r\n        let r = arr.length\r\n        while (l < r) {\r\n            const mid = (l + r >>> 1)\r\n            if (arr[mid]! < key) {\r\n                l = mid + 1\r\n            } else {\r\n                r = mid\r\n            }\r\n        }\r\n        return l\r\n    }\r\n}\r\n","import { RequestContext, Handler, Pipe } from './http.js'\r\n\r\nexport function compose<Ctx extends RequestContext>(\r\n    pipes: readonly Pipe<Ctx>[]|undefined,\r\n    handler: Handler<Ctx>\r\n): Handler<Ctx> {\r\n    if (!pipes || pipes.length === 0) {\r\n        return handler\r\n    }\r\n    return async (ctx: Ctx) => {\r\n        for (const pipe of pipes) {\r\n            await pipe(ctx)\r\n        }\r\n        return handler(ctx)\r\n    }\r\n}\r\n","// PatternRouteType.ts\r\nimport { IRouteType, Handler, RequestContext, RouteRuleBase, Pipe } from '../core/http.js'\r\nimport { compose } from '../core/compose.js'\r\n\r\nexport type Method = 'GET'|'HEAD'|'POST'|'PUT'|'PATCH'|'DELETE'|'OPTIONS'\r\n\r\nexport interface PatternRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx>\r\n{\r\n    pattern: string\r\n    methods?: Method[]\r\n    constraints?: Record<string, 'int'|'uuid'|'hex'|'alpha'|RegExp|((v: string) => boolean)>\r\n}\r\n\r\n/* ---------------- internals ---------------- */\r\n\r\ntype Validator = (v: string) => boolean\r\n\r\nconst BuiltinValidators: Record<string, Validator> = {\r\n    int:   v => /^-?\\d+$/.test(v),\r\n    uuid:  v => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v),\r\n    hex:   v => /^[0-9a-f]+$/i.test(v),\r\n    alpha: v => /^[A-Za-z]+$/.test(v),\r\n}\r\n\r\nfunction toValidator(\r\n    spec: 'int'|'uuid'|'hex'|'alpha'|RegExp|((v: string) => boolean)|undefined\r\n): Validator|undefined {\r\n    if (!spec) {\r\n        return undefined\r\n    }\r\n    if (typeof spec === 'function') {\r\n        return spec\r\n    }\r\n    if (spec instanceof RegExp) {\r\n        const r = spec\r\n        return v => r.test(v)\r\n    }\r\n    return BuiltinValidators[spec]\r\n}\r\n\r\ntype Token =\r\n    | { t: 'static', val: string }\r\n    | { t: 'param', name: string, validate?: Validator }\r\n    | { t: 'wildcard', name: string } // останній сегмент\r\n\r\nfunction normalizePath(p: string) {\r\n    if (!p || p === '/') {\r\n        return '/'\r\n    }\r\n    return p.endsWith('/') ? p.slice(0, -1) : p\r\n}\r\n\r\nfunction decodeSafe(s: string): string|null {\r\n    try {\r\n        return decodeURIComponent(s)\r\n    } catch {\r\n        return null\r\n    }\r\n}\r\n\r\nfunction parsePattern(pattern: string, constraints?: PatternRule['constraints']): Token[] {\r\n    const clean = normalizePath(pattern)\r\n    if (clean === '/') {\r\n        return []\r\n    }\r\n    const parts = clean.slice(1).split('/')\r\n\r\n    const tokens: Token[] = []\r\n    for (let i = 0; i < parts.length; i++) {\r\n        const seg = parts[i]!\r\n        if (seg.startsWith(':')) {\r\n            const m = /^:([A-Za-z_][A-Za-z0-9_]*)(?:\\((.+)\\))?$/.exec(seg)\r\n            if (!m) {\r\n                throw new Error(`Invalid param segment: ${seg}`)\r\n            }\r\n            const name = m[1]\r\n            if (!name) {\r\n                throw new Error(`Invalid param name in segment: ${seg}`)\r\n            }\r\n            let validate: Validator|undefined\r\n            if (m[2]) {\r\n                validate = toValidator(new RegExp(`^(?:${m[2]})$`))\r\n            } else if (constraints && constraints[name]) {\r\n                validate = toValidator(constraints[name])\r\n            }\r\n            tokens.push({ t: 'param', name, validate })\r\n            continue\r\n        }\r\n        if (seg === '*' || seg.startsWith('*')) {\r\n            const name = seg === '*' ? 'wild' : seg.slice(1)\r\n            if (i !== parts.length - 1) {\r\n                throw new Error('Wildcard must be the last segment')\r\n            }\r\n            tokens.push({ t: 'wildcard', name })\r\n            continue\r\n        }\r\n        tokens.push({ t: 'static', val: seg })\r\n    }\r\n    return tokens\r\n}\r\n\r\ntype Exec<Ctx extends RequestContext> = Handler<Ctx>\r\n\r\nclass Node<Ctx extends RequestContext> {\r\n    sChildren: Map<string, Node<Ctx>>|null = null\r\n    pChild: { name: string, validate?: Validator, node: Node<Ctx> }|null = null\r\n    wChild: { name: string, node: Node<Ctx> }|null = null\r\n    handlers: Map<Method, Exec<Ctx>>|null = null\r\n\r\n    getOrAddStatic(seg: string) {\r\n        if (!this.sChildren) {\r\n            this.sChildren = new Map()\r\n        }\r\n        let n = this.sChildren.get(seg)\r\n        if (!n) {\r\n            n = new Node<Ctx>()\r\n            this.sChildren.set(seg, n)\r\n        }\r\n        return n\r\n    }\r\n\r\n    setParam(name: string, validate?: Validator) {\r\n        // Обмеження на додавання param після wildcard видалено, оскільки пріоритет визначається під час матчингу.\r\n        if (!this.pChild) {\r\n            this.pChild = { name, validate, node: new Node<Ctx>() }\r\n        }\r\n        return this.pChild.node\r\n    }\r\n\r\n    setWildcard(name: string) {\r\n        if (!this.wChild) {\r\n            this.wChild = { name, node: new Node<Ctx>() }\r\n        }\r\n        return this.wChild.node\r\n    }\r\n\r\n    setHandler(methods: Method[], exec: Exec<Ctx>) {\r\n        if (!this.handlers) {\r\n            this.handlers = new Map()\r\n        }\r\n        for (const m of methods) {\r\n            if (this.handlers.has(m)) {\r\n                throw new Error(`Duplicate handler for method ${m}`)\r\n            }\r\n            this.handlers.set(m, exec)\r\n        }\r\n    }\r\n\r\n    getHandler(method: Method): Exec<Ctx>|null {\r\n        if (!this.handlers) {\r\n            return null\r\n        }\r\n        const h = this.handlers.get(method) || (method === 'HEAD' ? this.handlers.get('GET') : undefined)\r\n        return h ?? null\r\n    }\r\n}\r\n\r\n/* ---------------- exported route type ---------------- */\r\n\r\nexport class PatternRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, PatternRule<Ctx>>\r\n{\r\n    readonly typeName = 'PATH_PATTERN' as const\r\n    private root = new Node<Ctx>()\r\n\r\n    addRule(rule: PatternRule<Ctx>) {\r\n        const methods: Method[] = rule.methods?.length\r\n            ? rule.methods\r\n            : ['GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS']\r\n\r\n        const tokens = parsePattern(rule.pattern, rule.constraints)\r\n        const exec = compose(rule.pipes as readonly Pipe<Ctx>[]|undefined, rule.handler as Handler<Ctx>)\r\n\r\n        let node = this.root\r\n        for (let i = 0; i < tokens.length; i++) {\r\n            const t = tokens[i]!\r\n            if (t.t === 'static') {\r\n                node = node.getOrAddStatic(t.val)\r\n            } else if (t.t === 'param') {\r\n                node = node.setParam(t.name, t.validate)\r\n            } else {\r\n                node = node.setWildcard(t.name)\r\n                if (i !== tokens.length - 1) {\r\n                    throw new Error('Wildcard must be the last segment')\r\n                }\r\n            }\r\n        }\r\n        node.setHandler(methods, exec)\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx>|null {\r\n        const pathname = normalizePath(ctx.url.pathname)\r\n        const method = (ctx.req.method as Method) || 'GET'\r\n\r\n        if (pathname === '/') {\r\n            // Спочатку перевіряємо статичний обробник для кореневого шляху\r\n            let h = this.root.getHandler(method)\r\n            if (h) {\r\n                return h\r\n            }\r\n            // Якщо статичного обробника немає, перевіряємо wildcard для кореневого шляху (наприклад, /*path)\r\n            if (this.root.wChild) {\r\n                h = this.root.wChild.node.getHandler(method)\r\n                if (h) {\r\n                    // Для кореневого шляху параметр wildcard має бути порожнім рядком\r\n                    return (c: Ctx) => {\r\n                        (c as any).params = { [this.root.wChild!.name]: '' }\r\n                        return h!(c)\r\n                    }\r\n                }\r\n            }\r\n            return null\r\n        }\r\n\r\n        const parts = pathname.slice(1).split('/')\r\n\r\n        let params: Record<string, string>|null = null\r\n\r\n        const go = (node: Node<Ctx>, idx: number): Exec<Ctx>|null => {\r\n            if (idx === parts.length) {\r\n                return node.getHandler(method)\r\n            }\r\n\r\n            const segRaw = parts[idx]\r\n            if (segRaw === undefined) {\r\n                return null\r\n            }\r\n\r\n            const segDec = decodeSafe(segRaw)\r\n            if (segDec === null) {\r\n                return null\r\n            }\r\n\r\n            if (node.sChildren) {\r\n                const next = node.sChildren.get(segDec)\r\n                if (next) {\r\n                    const h = go(next, idx + 1)\r\n                    if (h) {\r\n                        return h\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (node.pChild) {\r\n                const { name, validate, node: pnode } = node.pChild\r\n                if (!validate || validate(segDec)) {\r\n                    if (!params) {\r\n                        params = Object.create(null)\r\n                    }\r\n                    params![name] = segDec\r\n                    const h = go(pnode, idx + 1)\r\n                    if (h) {\r\n                        return h\r\n                    }\r\n                    delete params![name]\r\n                }\r\n            }\r\n\r\n            if (node.wChild) {\r\n                let acc = ''\r\n                for (let i = idx; i < parts.length; i++) {\r\n                    const d = decodeSafe(parts[i]!)\r\n                    if (d === null) {\r\n                        return null\r\n                    }\r\n                    acc += (i === idx ? '' : '/') + d\r\n                }\r\n                if (!params) {\r\n                    params = Object.create(null)\r\n                }\r\n                params![node.wChild.name] = acc\r\n                const h = node.wChild.node.getHandler(method)\r\n                if (h) {\r\n                    return h\r\n                }\r\n                delete params![node.wChild.name]\r\n            }\r\n\r\n            return null\r\n        }\r\n\r\n        const found = go(this.root, 0)\r\n        if (!found) {\r\n            return null\r\n        }\r\n\r\n        return (c: Ctx) => {\r\n            if (params) {\r\n                ;(c as any).params = params\r\n            }\r\n            return found(c)\r\n        }\r\n    }\r\n}\r\n","import { createReadStream, promises as fsp, Stats } from 'node:fs'\r\nimport { extname } from 'node:path'\r\n\r\nimport { RequestContext, IRouteType, RouteRuleBase, Handler } from '../core/http.js'\r\n\r\nimport { StaticIndex } from '../services/StaticIndex.js'\r\n\r\nexport type ContentTypeMap = Record<string, string>\r\n\r\nexport interface StaticRouteOptions {\r\n    index: StaticIndex\r\n\r\n    /** Complete custom MIME resolver function. Takes precedence over the map. */\r\n    resolveContentType?: (\r\n        ext: string,\r\n        absPath: string,\r\n        stats: Stats,\r\n        ctx: RequestContext\r\n    ) => string | undefined\r\n\r\n    /** Additional or alternative types. Keys are extensions with a dot, e.g. \".md\". */\r\n    contentTypes?: ContentTypeMap\r\n\r\n    /** MIME is the default if nothing else works. */\r\n    defaultContentType?: string\r\n\r\n    /** Auto-add charset for text/* and application/json. Default is 'utf-8'. */\r\n    defaultTextCharset?: string | false\r\n}\r\n\r\n// Base map. Keys are in lower-case, with a period.\r\nconst BASE_CT: ContentTypeMap = {\r\n    '.html':'text/html; charset=utf-8', '.json':'application/json; charset=utf-8', '.txt':'text/plain; charset=utf-8',\r\n    '.js':'application/javascript; charset=utf-8', '.css':'text/css; charset=utf-8',\r\n    '.png':'image/png', '.jpg':'image/jpeg', '.jpeg':'image/jpeg', '.webp':'image/webp', '.gif':'image/gif', '.svg':'image/svg+xml',\r\n    '.mp4':'video/mp4', '.webm':'video/webm', '.mp3':'audio/mpeg', '.wav':'audio/wav',\r\n}\r\n\r\nfunction normalizeCTMap(src?: ContentTypeMap): ContentTypeMap {\r\n    if (!src) {\r\n        return {}\r\n    }\r\n    const out: ContentTypeMap = {}\r\n    for (const [k, v] of Object.entries(src)) {\r\n        const key = k.startsWith('.') ? k.toLowerCase() : ('.' + k.toLowerCase())\r\n        out[key] = v\r\n    }\r\n    return out\r\n}\r\n\r\nfunction maybeAppendCharset(mime: string, charset: string | false | undefined): string {\r\n    if (!charset) return mime\r\n    // Add charset if it's text/* or application/json and not already added\r\n    if ((/^text\\//.test(mime) || /^application\\/json\\b/.test(mime)) && !/;\\s*charset=/i.test(mime)) {\r\n        return `${mime}; charset=${charset}`\r\n    }\r\n    return mime\r\n}\r\n\r\nexport interface StaticRule<Ctx extends RequestContext = RequestContext>\r\n    extends RouteRuleBase<Ctx> \r\n{\r\n    methods?: ('GET'|'HEAD')[]\r\n}\r\n\r\n\r\nexport class StaticRouteType<Ctx extends RequestContext = RequestContext>\r\n    implements IRouteType<Ctx, StaticRule<Ctx>> \r\n{\r\n    readonly typeName = 'STATIC' as const\r\n\r\n    private readonly ct: ContentTypeMap\r\n    private readonly resolveCT?: StaticRouteOptions['resolveContentType']\r\n    private readonly defaultCT: string\r\n    private readonly defaultTextCharset: string | false\r\n\r\n    constructor(private cfg: StaticRouteOptions) {\r\n        this.resolveCT = cfg.resolveContentType\r\n        // Користувацькі типи перекривають базові (merge)\r\n        this.ct = { ...BASE_CT, ...normalizeCTMap(cfg.contentTypes) }\r\n        this.defaultCT = cfg.defaultContentType ?? 'application/octet-stream'\r\n        this.defaultTextCharset = cfg.defaultTextCharset ?? 'utf-8'\r\n    }\r\n\r\n    addRule(_rule: StaticRule<Ctx>): void {\r\n        // для STATIC зазвичай 1 правило на індекс; pipes можна навісити глобально на Router або тут\r\n    }\r\n\r\n    match(ctx: Ctx): Handler<Ctx> | null {\r\n        if (ctx.req.method !== 'GET' && ctx.req.method !== 'HEAD') {\r\n            return null\r\n        }\r\n        const abs = this.cfg.index.resolveUrl(ctx.url)\r\n        if (!abs) return null\r\n\r\n        return async (c: Ctx): Promise<void>  => {\r\n            const stats = await fsp.stat(abs)\r\n            const size = stats.size\r\n            const isHead = c.req.method === 'HEAD'\r\n\r\n            const ext = extname(abs).toLowerCase()\r\n            const resolvedMime =\r\n                this.resolveCT?.(ext, abs, stats, c)\r\n                ?? this.ct[ext]\r\n                ?? this.defaultCT\r\n\r\n            c.header('X-Content-Type-Options', 'nosniff')\r\n            c.header('Accept-Ranges', 'bytes')\r\n            c.header('Last-Modified', stats.mtime.toUTCString())\r\n            c.header('Content-Type', maybeAppendCharset(resolvedMime, this.defaultTextCharset))\r\n\r\n            // ETag слабкий: W/\"size-mtimeMs\"\r\n            const etag = `W/\"${size}-${Math.trunc(stats.mtimeMs)}\"`\r\n            c.header('ETag', etag)\r\n            if (c.req.headers['if-none-match'] === etag) { \r\n                c.status(304)\r\n                c.res.end()\r\n                return\r\n            }\r\n\r\n            const range = c.req.headers['range']\r\n            if (range && range.startsWith('bytes=')) {\r\n                let [s, e] = range.slice(6).split('-')\r\n                let start = s ? parseInt(s, 10) : 0\r\n                let end = e ? parseInt(e, 10) : size - 1\r\n                if (Number.isNaN(start)) start = 0\r\n                if (Number.isNaN(end)) end = size - 1\r\n                if (start > end || start >= size) {\r\n                    c.status(416).header('Content-Range', `bytes */${size}`)\r\n                    c.res.end()\r\n                    return\r\n                }\r\n                c.status(206).header('Content-Range', `bytes ${start}-${end}/${size}`)\r\n                c.header('Content-Length', String(end - start + 1))\r\n                if (isHead) {\r\n                    c.res.end()\r\n                    return\r\n                }\r\n                const rs = createReadStream(abs, { start, end })\r\n                rs.on('error', () => c.res.destroy())\r\n                rs.pipe(c.res)\r\n                return\r\n            }\r\n\r\n            c.status(200).header('Content-Length', String(size))\r\n            if (isHead) {\r\n                c.res.end()\r\n                return \r\n            }\r\n            const rs = createReadStream(abs)\r\n            rs.on('error', () => c.res.destroy())\r\n            rs.pipe(c.res)\r\n        }\r\n    }\r\n}\r\n"],"names":["HttpException","statusCode","message","expose","headers","RequestContext","req","res","code","k","v","obj","s","limit","resolve","reject","chunks","size","done","fail","err","ok","c","raw","Router","opts","type","pipes","rule","t","_omit","pureRule","rules","r","ctx","base","globalPipe","name","exec","e","StaticIndex","path","next","visitedDirs","rootReal","fsp","inRoot","p","walk","dirAbs","rel","depth","entries","dirReal","childAbs","childRel","lst","error","targetReal","st","urlPath","url","pathname","abs","compose","handler","pipe","normalizePath","METHOD_ORDER","PathRouteType","methods","m","exe","key","i","set","method","getKey","getHandler","originalResEnd","chunk","allowed","allowList","ordered","allowHeader","arr","l","mid","BuiltinValidators","toValidator","spec","decodeSafe","parsePattern","pattern","constraints","clean","parts","tokens","seg","validate","Node","n","PatternRouteType","node","h","params","go","idx","segRaw","segDec","pnode","acc","d","found","BASE_CT","normalizeCTMap","src","out","maybeAppendCharset","mime","charset","StaticRouteType","cfg","_rule","stats","isHead","ext","extname","resolvedMime","etag","range","start","end","rs","createReadStream"],"mappings":"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"}